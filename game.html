<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <!-- Adaptation mobile -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Titre éditable -->
  <title data-sb-field="gamePageTitle">Flappy Trump</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: black;
      overflow: hidden;
      height: 100%;
      font-family: 'Press Start 2P', cursive;
    }
    canvas {
      display: block;
    }
    /* Bouton "Commencer" centré sur l'écran */
    #startButton {
      color: #00FF00;
      text-decoration: none;
      background: transparent;
      border: 2px solid #00FF00;
      padding: 10px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
    }
    #startButton:hover {
      background: #00FF00;
      color: black;
    }
    /* Conteneur pour les boutons en fin de partie */
    #gameOverContainer {
      position: absolute;
      bottom: 20%;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }
    #gameOverContainer button,
    #gameOverContainer a {
      font-family: 'Press Start 2P', cursive;
      color: #00FF00;
      text-decoration: none;
      background: transparent;
      border: 2px solid #00FF00;
      padding: 10px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    #gameOverContainer button:hover,
    #gameOverContainer a:hover {
      background: #00FF00;
      color: black;
    }
    /* Responsive adjustments */
    @media (max-width: 768px) {
      #startButton, 
      #gameOverContainer button, 
      #gameOverContainer a {
        font-size: 0.9rem;
        padding: 8px;
      }
    }
    @media (min-width: 769px) and (max-width: 1024px) {
      #startButton, 
      #gameOverContainer button, 
      #gameOverContainer a {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <!-- Élément de configuration éditable -->
  <div id="gameConfig" style="display: none;" data-sb-field="gameConfig">
    <span id="startText" data-sb-field="gameStartText">Commencer</span>
  </div>

  <!-- Canvas du jeu -->
  <canvas id="gameCanvas"></canvas>

  <!-- Conteneur pour les boutons de fin de partie -->
  <div id="gameOverContainer">
    <button id="restartButton" data-sb-field="gameRestartButtonText">Recommencer</button>
    <a href="index.html" id="homeLink" data-sb-field="gameHomeButtonText">Retour à l'accueil</a>
  </div>
  <!-- Bouton "Commencer" -->
  <button id="startButton">Commencer</button>
  
  <script>
    /***** CONFIGURATION CENTRALISÉE *****/
    const CONFIG = {
      CANVAS_BG: "black",
      FONT_FAMILY: "'Press Start 2P', cursive",
      TEXT_COLOR: "#00FF00",
      PIPE_WIDTH: 80,
      GRAVITY: 0.5,
      JUMP_STRENGTH: -10,
      PIPE_SPEED: 2,
      PIPE_INTERVAL: 1700, // espacement horizontal légèrement augmenté
      GAP_HEIGHT_SMALL: 300,
      GAP_HEIGHT_LARGE: 200,
      TRANSITION_DURATION: 500,
      GAMEOVER_FONT_SIZE: 60,
      SCORE_FONT_SIZE: 40
    };

    /***** RÉCUPÉRATION DES ÉLÉMENTS DU DOM *****/
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const startButton = document.getElementById("startButton");
    const gameOverContainer = document.getElementById("gameOverContainer");
    const restartButton = document.getElementById("restartButton");
    const homeLink = document.getElementById("homeLink");

    /***** DIMENSIONNEMENT DU CANVAS *****/
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gapHeight = window.innerWidth < 768 ? CONFIG.GAP_HEIGHT_SMALL : CONFIG.GAP_HEIGHT_LARGE;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    /***** MUSIQUE DE FOND *****/
    const bgMusic = new Audio("assets/flappy.mp3");
    bgMusic.loop = true;
    bgMusic.volume = 0.5;
    
    /***** ÉTATS DU JEU *****/
    const STATE = {
      START: 'start',
      TRANSITION: 'transition',
      AUTO_JUMP: 'autoJump',
      PLAYING: 'playing',
      GAMEOVER: 'gameover'
    };
    let gameState = STATE.START;
    
    /***** GESTION DES ÉVÉNEMENTS *****/
    // Suivi de la souris (pour d'éventuelles interactions)
    let mouseX = 0, mouseY = 0;
    canvas.addEventListener("mousemove", e => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });
    
    // Amélioration du tactile sur mobile
    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      if (gameState === STATE.PLAYING) {
        bird.velocity = CONFIG.JUMP_STRENGTH;
      }
    });
    
    // Gestion du clavier pour le saut
    document.addEventListener("keydown", e => {
      if (e.code === "Space") {
        e.preventDefault();
        if (gameState === STATE.PLAYING) {
          bird.velocity = CONFIG.JUMP_STRENGTH;
        }
      }
    });
    
    // Clic sur le canvas pour sauter
    canvas.addEventListener("click", () => {
      if (gameState === STATE.PLAYING) {
        bird.velocity = CONFIG.JUMP_STRENGTH;
      }
    });
    
    // Bouton "Commencer"
    startButton.style.display = "block";
    startButton.addEventListener("click", () => {
      bgMusic.play();
      startButton.style.display = "none";
      startTransition();
    });
    
    // Bouton "Recommencer"
    restartButton.addEventListener("click", () => {
      restartGame();
    });
    
    // Bouton "Retour à l'accueil" : arrêt de la musique
    homeLink.addEventListener("click", () => {
      bgMusic.pause();
    });
    
    /***** INITIALISATION DU JEU *****/
    // Propriétés du "bird"
    const bird = {
      x: canvas.width / 4,
      y: canvas.height / 2,
      width: 50,
      height: 50,
      velocity: 0,
      gravity: CONFIG.GRAVITY,
      jumpStrength: CONFIG.JUMP_STRENGTH
    };
    
    // Gap entre tuyaux
    let gapHeight = window.innerWidth < 768 ? CONFIG.GAP_HEIGHT_SMALL : CONFIG.GAP_HEIGHT_LARGE;
    const pipeWidth = CONFIG.PIPE_WIDTH;
    let pipeInterval = CONFIG.PIPE_INTERVAL;
    let lastPipeTime = 0;
    
    // Score
    let score = 0;
    
    // Variables pour l'auto-jump
    let autoJumpCount = 0;
    let autoJumpTimer = 0;
    
    // Timer de transition
    let transitionTimer = 0;
    
    // Liste des tuyaux
    let pipes = [];
    
    // Fonction pour générer un tuyau
    function spawnPipe() {
      const gapPosition = Math.random() * (canvas.height - gapHeight - 200) + 100;
      const topHeight = gapPosition;
      const bottomHeight = canvas.height - gapPosition - gapHeight;
      pipes.push({ x: canvas.width, top: topHeight, bottom: bottomHeight, passed: false });
    }
    
    // Démarrer la transition
    function startTransition() {
      gameState = STATE.TRANSITION;
      transitionTimer = 0;
    }
    
    // Redémarrer le jeu
    function restartGame() {
      gameState = STATE.START;
      bird.y = canvas.height / 2;
      bird.velocity = 0;
      pipes = [];
      score = 0;
      autoJumpCount = 0;
      autoJumpTimer = 0;
      lastPipeTime = 0;
      gameOverContainer.style.display = "none";
      startButton.style.display = "block";
    }
    
    // Mise à jour de l'affichage des boutons en fonction de l'état
    function updateButtons() {
      if (gameState === STATE.START) {
        gameOverContainer.style.display = "none";
        startButton.style.display = "block";
      } else if (gameState === STATE.GAMEOVER) {
        gameOverContainer.style.display = "flex";
        startButton.style.display = "none";
      } else {
        gameOverContainer.style.display = "none";
        startButton.style.display = "none";
      }
    }
    
    /***** BOUCLE DE JEU *****/
    let lastTime = 0;
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      
      // Effacer le canvas
      ctx.fillStyle = CONFIG.CANVAS_BG;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      updateButtons();
      
      if (gameState === STATE.START) {
        // Le bouton "Commencer" est géré par l'élément HTML.
      } else if (gameState === STATE.TRANSITION) {
        transitionTimer += deltaTime;
        const alpha = Math.min(1, transitionTimer / CONFIG.TRANSITION_DURATION);
        ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        if (transitionTimer >= CONFIG.TRANSITION_DURATION) {
          gameState = STATE.AUTO_JUMP;
          autoJumpTimer = 0;
        }
      } else if (gameState === STATE.AUTO_JUMP) {
        autoJumpTimer += deltaTime;
        if (autoJumpCount === 0 && autoJumpTimer > 200) {
          bird.velocity = bird.jumpStrength;
          autoJumpCount++;
        } else if (autoJumpCount === 1 && autoJumpTimer > 400) {
          bird.velocity = bird.jumpStrength;
          autoJumpCount++;
        } else if (autoJumpCount === 2 && autoJumpTimer > 600) {
          gameState = STATE.PLAYING;
        }
        bird.velocity += bird.gravity;
        bird.y += bird.velocity;
        ctx.drawImage(donaldImg, bird.x, bird.y, bird.width, bird.height);
        ctx.fillStyle = CONFIG.TEXT_COLOR;
        ctx.font = "20px " + CONFIG.FONT_FAMILY;
        ctx.textAlign = "left";
        ctx.fillText(score, 20, 40);
      } else if (gameState === STATE.PLAYING) {
        if (pipes.length === 0) {
          spawnPipe();
          lastPipeTime = timestamp;
        }
        bird.velocity += bird.gravity;
        bird.y += bird.velocity;
        
        if (timestamp - lastPipeTime > pipeInterval) {
          spawnPipe();
          lastPipeTime = timestamp;
        }
        
        pipes.forEach(pipe => {
          pipe.x -= CONFIG.PIPE_SPEED;
          if (checkCollision(bird, pipe)) {
            gameState = STATE.GAMEOVER;
          }
          if (!pipe.passed && pipe.x + pipeWidth < bird.x) {
            score += 50;
            pipe.passed = true;
          }
          // Dessiner le tuyau supérieur
          ctx.fillStyle = "green";
          ctx.fillRect(pipe.x, 0, pipeWidth, pipe.top);
          ctx.strokeStyle = "#003300";
          ctx.lineWidth = 4;
          ctx.strokeRect(pipe.x, 0, pipeWidth, pipe.top);
          // Dessiner le tuyau inférieur
          ctx.fillStyle = "green";
          ctx.fillRect(pipe.x, canvas.height - pipe.bottom, pipeWidth, pipe.bottom);
          ctx.strokeStyle = "#003300";
          ctx.lineWidth = 4;
          ctx.strokeRect(pipe.x, canvas.height - pipe.bottom, pipeWidth, pipe.bottom);
        });
        pipes = pipes.filter(pipe => pipe.x + pipeWidth > 0);
        
        ctx.drawImage(donaldImg, bird.x, bird.y, bird.width, bird.height);
        ctx.fillStyle = CONFIG.TEXT_COLOR;
        ctx.font = "20px " + CONFIG.FONT_FAMILY;
        ctx.textAlign = "left";
        ctx.fillText(score, 20, 40);
        
        if (bird.y + bird.height > canvas.height) {
          gameState = STATE.GAMEOVER;
        }
      } else if (gameState === STATE.GAMEOVER) {
        // Affichage du message de défaite et du score, centrés en haut de la zone des boutons
        ctx.fillStyle = CONFIG.TEXT_COLOR;
        ctx.textAlign = "center";
        ctx.font = CONFIG.GAMEOVER_FONT_SIZE + "px " + CONFIG.FONT_FAMILY;
        const gameOverTextY = canvas.height * 0.4;
        ctx.fillText("T'AS PERDU", canvas.width / 2, gameOverTextY);
        ctx.font = CONFIG.SCORE_FONT_SIZE + "px " + CONFIG.FONT_FAMILY;
        const scoreTextY = canvas.height * 0.5;
        ctx.fillText("Score : " + score, canvas.width / 2, scoreTextY);
      }
      
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
    
    /***** VÉRIFICATION DE COLLISION *****/
    function checkCollision(bird, pipe) {
      const tx = pipe.x, ty = 0, tw = pipeWidth, th = pipe.top;
      const bx_pipe = pipe.x, by_pipe = canvas.height - pipe.bottom, bw_pipe = pipeWidth, bh_pipe = pipe.bottom;
      const bx = bird.x, by = bird.y, bw = bird.width, bh = bird.height;
      if (bx < tx + tw && bx + bw > tx && by < ty + th && by + bh > ty) return true;
      if (bx < bx_pipe + bw_pipe && bx + bw > bx_pipe && by < by_pipe + bh_pipe && by + bh > by_pipe) return true;
      return false;
    }
    
    /***** CHARGEMENT DE L'IMAGE *****/
    const donaldImg = new Image();
    donaldImg.src = "assets/donald.jpg";
  </script>
</body>
</html>