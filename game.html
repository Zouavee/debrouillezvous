<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <!-- Titre éditable -->
  <title data-sb-field="gamePageTitle">Flappy Trump</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      /* Fond noir uniquement */
      background-color: black;
      overflow: hidden;
      height: 100%;
      font-family: 'Press Start 2P', cursive;
    }
    canvas {
      display: block;
    }
    /* Boutons interactifs */
    #homeLink, #restartButton, #startButton {
      font-family: 'Press Start 2P', cursive;
      color: #00FF00;
      text-decoration: none;
      background: transparent;
      border: 2px solid #00FF00;
      padding: 10px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      z-index: 10;
      position: absolute;
    }
    #homeLink:hover, #restartButton:hover, #startButton:hover {
      background: #00FF00;
      color: black;
    }
    /* Positionnement des boutons */
    #homeLink {
      bottom: 20px;
      right: 20px;
      display: none;
    }
    #restartButton {
      bottom: 20px;
      left: 20px;
      display: none;
    }
    /* Bouton "Commencer" centré sur l'écran */
    #startButton {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: block;
    }
    /* Responsive adjustments */
    @media (max-width: 768px) {
      #homeLink, #restartButton, #startButton {
        font-size: 0.9rem;
        padding: 8px;
      }
      #restartButton {
        bottom: 80px;
        left: 20px;
      }
    }
    @media (min-width: 769px) and (max-width: 1024px) {
      #homeLink, #restartButton, #startButton {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <!-- Élément audio permanent pour la musique (reste inchangé grâce à Turbolinks) -->
  <audio id="backgroundMusic" autoplay loop muted data-turbolinks-permanent>
    <source src="assets/flappy.mp3" type="audio/mp3">
    Votre navigateur ne supporte pas la lecture de fichiers audio.
  </audio>
  
  <!-- Élément de configuration éditable (texte pour le bouton "Commencer") -->
  <div id="gameConfig" style="display: none;" data-sb-field="gameConfig">
    <span id="startText" data-sb-field="gameStartText">Commencer</span>
  </div>
  
  <!-- Le canvas pour le jeu -->
  <canvas id="gameCanvas"></canvas>
  
  <!-- Bouton "Retour à l'accueil" éditable -->
  <a href="index.html" id="homeLink" data-sb-field="gameHomeButtonText">Retour à l'accueil</a>
  <!-- Bouton "Recommencer" éditable -->
  <button id="restartButton" data-sb-field="gameRestartButtonText">Recommencer</button>
  
  <script>
    // --- Définition des constantes ---
    const PIPE_WIDTH = 80;
    const GAP_HEIGHT_MOBILE = 350;
    const GAP_HEIGHT_DESKTOP = 250;
    const PIPE_INTERVAL_MOBILE = 2000;  // Augmenté pour espacer davantage les paires sur mobile
    const PIPE_INTERVAL_DESKTOP = 1500;
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Définir le gapHeight et pipeInterval en fonction de la taille d'écran
    let gapHeight = window.innerWidth < 768 ? GAP_HEIGHT_MOBILE : GAP_HEIGHT_DESKTOP;
    let pipeInterval = window.innerWidth < 768 ? PIPE_INTERVAL_MOBILE : PIPE_INTERVAL_DESKTOP;
    
    // Musique de fond
    const bgMusic = new Audio("assets/flappy.mp3");
    bgMusic.loop = true;
    bgMusic.volume = 0.5;
    
    // États du jeu
    const STATE = {
      START: 'start',
      TRANSITION: 'transition',
      AUTO_JUMP: 'autoJump',
      PLAYING: 'playing',
      GAMEOVER: 'gameover'
    };
    let gameState = STATE.START;
    
    // Variables pour la gestion du jeu
    let mouseX = 0, mouseY = 0;
    let score = 0;
    let lastPipeTime = 0;
    let autoJumpCount = 0;
    let autoJumpTimer = 0;
    let transitionTimer = 0;
    
    // Déclaration unique du tableau de tuyaux
    let pipes = [];
    
    // --- Événements ---
    canvas.addEventListener("mousemove", (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });
    
    // Écouteur tactile pour mobile
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      if (gameState === STATE.START) {
        bgMusic.play();
        startTransition();
      } else if (gameState === STATE.PLAYING) {
        bird.velocity = bird.jumpStrength;
      }
    });
    
    // Clic sur le canvas (pour desktop)
    canvas.addEventListener("click", () => {
      if (gameState === STATE.START) {
        bgMusic.play();
        startTransition();
      } else if (gameState === STATE.PLAYING) {
        bird.velocity = bird.jumpStrength;
      }
    });
    
    // Bouton "Recommencer"
    const restartButton = document.getElementById("restartButton");
    restartButton.addEventListener("click", () => {
      restartGame();
    });
    
    // Bouton "Retour à l'accueil" : arrêter la musique
    const homeLink = document.getElementById("homeLink");
    homeLink.addEventListener("click", () => {
      bgMusic.pause();
    });
    
    // --- Propriétés du "bird" ---
    const bird = {
      x: canvas.width / 4,
      y: canvas.height / 2,
      width: 50,
      height: 50,
      velocity: 0,
      gravity: 0.5,
      jumpStrength: -10
    };
    
    // Chargement de l'image "donald"
    const donaldImg = new Image();
    donaldImg.src = "assets/donald.jpg";
    
    // --- Fonctions de jeu ---
    
    function spawnPipe() {
      // Calculer une position de gap aléatoire
      const gapPosition = Math.random() * (canvas.height - gapHeight - 200) + 100;
      const topHeight = gapPosition;
      const bottomHeight = canvas.height - gapPosition - gapHeight;
      pipes.push({ x: canvas.width, top: topHeight, bottom: bottomHeight, passed: false });
    }
    
    function checkCollision(b, p) {
      const { x: bx, y: by, width: bw, height: bh } = b;
      const { x: px, top: pt, bottom: pb } = p;
      // Collision avec le tuyau supérieur
      if (bx < px + PIPE_WIDTH && bx + bw > px && by < pt) return true;
      // Collision avec le tuyau inférieur
      if (bx < px + PIPE_WIDTH && bx + bw > px && by + bh > canvas.height - pb) return true;
      return false;
    }
    
    function updateGame(deltaTime) {
      if (gameState === STATE.START) {
        // Rien à mettre à jour pour l'instant
      } else if (gameState === STATE.TRANSITION) {
        transitionTimer += deltaTime;
        if (transitionTimer >= 500) {
          gameState = STATE.AUTO_JUMP;
          autoJumpTimer = 0;
        }
      } else if (gameState === STATE.AUTO_JUMP) {
        autoJumpTimer += deltaTime;
        if (autoJumpCount === 0 && autoJumpTimer > 200) {
          bird.velocity = bird.jumpStrength;
          autoJumpCount++;
        } else if (autoJumpCount === 1 && autoJumpTimer > 400) {
          bird.velocity = bird.jumpStrength;
          autoJumpCount++;
        } else if (autoJumpCount === 2 && autoJumpTimer > 600) {
          gameState = STATE.PLAYING;
        }
        bird.velocity += bird.gravity;
        bird.y += bird.velocity;
      } else if (gameState === STATE.PLAYING) {
        bird.velocity += bird.gravity;
        bird.y += bird.velocity;
        // Générer un tuyau si nécessaire
        if (pipes.length === 0 || (performance.now() - lastPipeTime > pipeInterval)) {
          spawnPipe();
          lastPipeTime = performance.now();
        }
        // Mettre à jour les tuyaux
        pipes.forEach(p => {
          p.x -= 2;
          if (!p.passed && p.x + PIPE_WIDTH < bird.x) {
            score += 50;
            p.passed = true;
          }
          if (checkCollision(bird, p)) {
            gameState = STATE.GAMEOVER;
          }
        });
        // Supprimer les tuyaux hors écran
        pipes = pipes.filter(p => p.x + PIPE_WIDTH > 0);
      }
    }
    
    function drawGame() {
      // Effacer le canvas
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      if (gameState === STATE.START) {
        // Affichage du bouton "Commencer" sur le canvas
        let startText = document.getElementById("startText").textContent || "Commencer";
        ctx.font = "40px 'Press Start 2P'";
        let metrics = ctx.measureText(startText);
        let textWidth = metrics.width;
        let paddingX = 20, paddingY = 10;
        let rectWidth = textWidth + 2 * paddingX;
        let rectHeight = 40 + 2 * paddingY;
        let rectX = canvas.width / 2 - rectWidth / 2;
        let rectY = canvas.height / 2 - rectHeight / 2;
        // Dessiner le bouton
        ctx.strokeStyle = "#00FF00";
        ctx.lineWidth = 3;
        ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
        ctx.fillStyle = "#00FF00";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(startText, canvas.width / 2, canvas.height / 2);
      } else if (gameState === STATE.TRANSITION) {
        let alpha = Math.min(1, transitionTimer / 500);
        ctx.fillStyle = "rgba(0, 0, 0," + alpha + ")";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else if (gameState === STATE.AUTO_JUMP) {
        // Dessiner l'oiseau pendant l'auto-jump
        ctx.drawImage(donaldImg, bird.x, bird.y, bird.width, bird.height);
        ctx.fillStyle = "#00FF00";
        ctx.font = "20px 'Press Start 2P'";
        ctx.textAlign = "left";
        ctx.fillText(score, 20, 40);
      } else if (gameState === STATE.PLAYING) {
        // Dessiner les tuyaux
        pipes.forEach(p => {
          // Tuyau supérieur
          ctx.fillStyle = "green";
          ctx.fillRect(p.x, 0, PIPE_WIDTH, p.top);
          ctx.strokeStyle = "#003300";
          ctx.lineWidth = 4;
          ctx.strokeRect(p.x, 0, PIPE_WIDTH, p.top);
          // Tuyau inférieur
          ctx.fillStyle = "green";
          ctx.fillRect(p.x, canvas.height - p.bottom, PIPE_WIDTH, p.bottom);
          ctx.strokeStyle = "#003300";
          ctx.lineWidth = 4;
          ctx.strokeRect(p.x, canvas.height - p.bottom, PIPE_WIDTH, p.bottom);
        });
        // Dessiner l'oiseau
        ctx.drawImage(donaldImg, bird.x, bird.y, bird.width, bird.height);
        // Afficher le score
        ctx.fillStyle = "#00FF00";
        ctx.font = "20px 'Press Start 2P'";
        ctx.textAlign = "left";
        ctx.fillText(score, 20, 40);
      } else if (gameState === STATE.GAMEOVER) {
        ctx.fillStyle = "#00FF00";
        ctx.font = "60px 'Press Start 2P'";
        ctx.textAlign = "center";
        ctx.fillText("T'AS PERDU", canvas.width / 2, canvas.height / 2);
        ctx.font = "40px 'Press Start 2P'";
        ctx.fillText("Score : " + score, canvas.width / 2, canvas.height / 2 + 60);
      }
    }
    
    let previousTimestamp = 0;
    function gameLoop(timestamp) {
      const deltaTime = timestamp - previousTimestamp;
      previousTimestamp = timestamp;
      
      updateGame(deltaTime);
      drawGame();
      
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
    
    window.addEventListener('resize', function() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gapHeight = window.innerWidth < 768 ? 350 : 250;
      pipeInterval = window.innerWidth < 768 ? PIPE_INTERVAL_MOBILE : PIPE_INTERVAL_DESKTOP;
    });
  </script>
</body>
</html>
